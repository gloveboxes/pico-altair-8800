<!DOCTYPE html>
<html>

<head>
  <script src="Javascript/xterm.js"></script>

  <link rel="stylesheet" href="css/xterm.css" />
  <link rel="stylesheet" href="css/modern.css">

  <script>
    "use strict";

    /**
     * Altair Terminal Web Client
     * Improved version with better error handling, code organization, and robustness
     */
    const AltairTerminal = (function() {
      // Private state - encapsulated to avoid global pollution
      const state = {
        ws: null,
        connected: false,
        online: navigator.onLine,
        term: null,
        reconnectAttempts: 0,
        maxReconnectAttempts: 5,
        reconnectDelay: 2000,
        pasteHandler: null,
        keyHandler: null,
        cleanupInterval: null,
        userInitiatedDisconnect: false
      };

      const decoder = new TextDecoder("utf-8", {fatal: false});

      // Configuration constants
      const CONFIG = {
        XTERM_FONT: 'Courier',
        XTERM_FONT_SIZE: 18,
        XTERM_ROWS: 30,
        XTERM_COLS: 100,
        WEBSOCKET_PORT: 8082,
        MAX_PASTE_LENGTH: 256,
        STORAGE_THEME_KEY: 'altair_theme',
        DEFAULT_THEME: 'dark',
        MAX_SCROLLBACK_LINES: 1000,
        BUFFER_CLEANUP_INTERVAL: 300000, // 5 minutes
        RECONNECT_DELAY: 2000
      };

      // DOM element cache
      const elements = {
        terminal: null,
        hostName: null,
        toggleTheme: null,
        reconnectBtn: null,
        sendEscBtn: null,
        sendCtrlCBtn: null,
        monitorBtn: null
      };

      function sendToServer(data) {
        if (!state.connected || !state.online || !state.ws || state.ws.readyState !== WebSocket.OPEN) {
          return;
        }

        if (typeof data === "string" && data.length === 0) {
          return;
        }

        if (data instanceof ArrayBuffer && data.byteLength === 0) {
          return;
        }

        try {
          state.ws.send(data);
        } catch (error) {
          console.error("Failed to send data:", error);
          showError("Failed to send data to server");
        }
      }

      function writeToTerminal(text) {
        if (!text || !state.term) {
          return;
        }

        try {
          state.term.write(text);
        } catch (error) {
          console.error("Error writing payload to terminal:", error);
        }
      }

      /**
       * Initialize DOM element references with error checking
       */
      function initializeElements() {
        try {
          elements.terminal = document.getElementById("terminal");
          elements.hostName = document.getElementById("host_name");
          elements.toggleTheme = document.getElementById("toggleTheme");
          elements.reconnectBtn = document.getElementById("reconnectBtn");
          elements.sendEscBtn = document.getElementById("sendEscBtn");
          elements.sendCtrlCBtn = document.getElementById("sendCtrlCBtn");
          elements.monitorBtn = document.getElementById("monitorBtn");

          // Validate critical elements exist
          if (!elements.terminal) {
            throw new Error("Terminal container element not found");
          }
        } catch (error) {
          console.error("Failed to initialize DOM elements:", error);
          showError("Failed to initialize terminal interface");
          return false;
        }
        return true;
      }

      // Add sendCtrlC button click handler
      function setupSendCtrlCButton() {
        if (!elements.sendCtrlCBtn) return;
        elements.sendCtrlCBtn.onclick = function() {
          if (state.connected && state.ws && state.ws.readyState === WebSocket.OPEN) {
            sendControlCharacter(3); // Ctrl+C
          }
          if (state.term) {
            state.term.focus();
          }
        };
      }

      // Add sendEsc button click handler
      function setupSendEscButton() {
        if (!elements.sendEscBtn) return;
        elements.sendEscBtn.onclick = function() {
          if (state.connected && state.ws && state.ws.readyState === WebSocket.OPEN) {
            sendControlCharacter(27); // ESC key
          }
          if (state.term) {
            state.term.focus();
          }
        };
      }

      // Add monitor button click handler
      function setupMonitorButton() {
        if (!elements.monitorBtn) return;
        elements.monitorBtn.onclick = function() {
          if (state.connected && state.ws && state.ws.readyState === WebSocket.OPEN) {
            sendControlCharacter(13); // Ctrl+M (CR)
          }
          if (state.term) {
            state.term.focus();
          }
        };
      }

      /**
       * Safe error display without using alert()
       */
      function showError(message) {
        console.error("Altair Terminal Error:", message);
        if (elements.hostName) {
          elements.hostName.textContent = `Error: ${message}`;
          elements.hostName.style.color = 'red';
        }
      }

      /**
       * Safe message display
       */
      function showMessage(message, isError = false) {
        console.log("Altair Terminal:", message);
        if (elements.hostName) {
          elements.hostName.textContent = message;
          elements.hostName.style.color = isError ? 'red' : '';
        }
        updateReconnectButton();
      }

      function updateReconnectButton() {
        if (!elements.reconnectBtn) return;

        const connected = state.connected && state.ws && state.ws.readyState === WebSocket.OPEN;
        elements.reconnectBtn.disabled = false;
        let hostText = "localhost";
        if (connected && state.ws && state.ws.url) {
          try {
            const url = new URL(state.ws.url);
            hostText = url.hostname;
          } catch (e) {}
        } else {
          // Use the host from getWebSocketUrl()
          try {
            const wsUrl = getWebSocketUrl();
            hostText = wsUrl.split('://')[1].split(':')[0];
          } catch (e) {}
        }
        elements.reconnectBtn.textContent = connected ? `Disconnect from ${hostText}` : `Connect to ${hostText}`;

        // Disable/enable control buttons based on connection state
        if (elements.sendEscBtn) elements.sendEscBtn.disabled = !connected;
        if (elements.sendCtrlCBtn) elements.sendCtrlCBtn.disabled = !connected;
        if (elements.monitorBtn) elements.monitorBtn.disabled = !connected;
      }
      // Add reconnect button click handler
      function setupReconnectButton() {
        if (!elements.reconnectBtn) return;
        elements.reconnectBtn.onclick = function() {
          if (state.connected && state.ws && state.ws.readyState === WebSocket.OPEN) {
            // Disconnect
            state.userInitiatedDisconnect = true;
            closeConnection();
            showMessage('Disconnected', true);
            updateReconnectButton();
          } else {
            // Connect
            attemptConnection();
          }
        };
      }

      /**
       * Network status management
       */
      function initializeNetworkHandlers() {
        window.addEventListener('offline', () => {
          console.log('Connection lost');
          state.online = false;
          showMessage('Connection lost', true);
        });

        window.addEventListener('online', () => {
          console.log('Connection restored');
          state.online = true;
          showMessage('Connection restored');
          // Attempt to reconnect if we were previously connected
          if (state.connected && (!state.ws || state.ws.readyState !== WebSocket.OPEN)) {
            setTimeout(() => attemptConnection(), 1000);
          }
        });
      }

      /**
       * Initialize xterm.js terminal with error handling
       */
      function initializeTerminal() {
        try {
          // Check if Terminal is available
          if (typeof Terminal === 'undefined') {
            throw new Error("xterm.js library not loaded");
          }

          // Get initial theme before creating terminal
          const initialTheme = localStorage.getItem(CONFIG.STORAGE_THEME_KEY) || CONFIG.DEFAULT_THEME;
          const themeColors = initialTheme === "light" 
            ? {
                background: '#ffffff',
                foreground: "#000000",
                cursor: "#000000",
                selectionBackground: "rgba(188,214,141, 0.4)"
              }
            : {
                background: '#000000',
                foreground: "#ffffff",
                cursor: "#ffffff",
                selectionBackground: "rgba(188,214,141, 0.4)"
              };

          state.term = new Terminal({
            cursorBlink: true,
            fontFamily: CONFIG.XTERM_FONT,
            fontSize: CONFIG.XTERM_FONT_SIZE,
            rows: CONFIG.XTERM_ROWS,
            cols: CONFIG.XTERM_COLS,
            theme: themeColors
          });

          if (!elements.terminal) {
            throw new Error("Terminal container not found");
          }

          state.term.open(elements.terminal);
          updateThemeButton(initialTheme === "light" ? "Dark" : "Light");
          // state.term.write('WELCOME TO ALTAIR TERMINAL');

          // Set up terminal prompt function
          state.term.prompt = (msg) => {
            sendToServer(msg);
          };

          state.term.prompt("");
          setupTerminalEventHandlers();
          
          // Set focus to terminal after initialization
          state.term.focus();
          
          return true;
        } catch (error) {
          console.error("Failed to initialize terminal:", error);
          showError("Failed to initialize terminal: " + error.message);
          return false;
        }
      }

      /**
       * Set up terminal event handlers with better error handling
       */
      function setupTerminalEventHandlers() {
        if (!state.term) return;

        // Remove existing handlers first to prevent accumulation
        cleanupTerminalEventHandlers();

        // Store handler references for cleanup
        state.pasteHandler = state.term.onData((data) => {
          // Character mode only - ignore paste data
          return;
        });

        state.keyHandler = state.term.onKey(({key, domEvent}) => {
          try {
            handleKeyPress(key, domEvent);
          } catch (error) {
            console.error("Error handling key press:", error);
          }
        });
      }

      /**
       * Clean up terminal event handlers
       */
      function cleanupTerminalEventHandlers() {
        if (state.pasteHandler) {
          try {
            state.pasteHandler.dispose();
          } catch (error) {
            console.error("Error removing paste handler:", error);
          }
        }
        if (state.keyHandler) {
          try {
            state.keyHandler.dispose();
          } catch (error) {
            console.error("Error removing key handler:", error);
          }
        }
        state.pasteHandler = null;
        state.keyHandler = null;
      }

      /**
       * Handle key press events with better organization
       */
      function handleKeyPress(key, ev) {
        if (ev.ctrlKey) {
          sendControlCharacter(ev.keyCode & 0x1F);
          return;
        }

        if (ev.keyCode === 27) {
          if (state.term) {
            state.term.prompt(key);
            state.term.write(key);
          } else {
            sendToServer(key);
          }
          return;
        }

        handleCharacterMode(key, ev);
      }

      /**
       * Handle character input mode
       */
      function handleCharacterMode(key, ev) {
        const ctrlCode = (letter) => letter.charCodeAt(0) & 0x1F;

        const keyMappings = {
          39: ctrlCode('D'), // cursor right -> ctrl D
          37: ctrlCode('S'), // cursor left -> ctrl S
          38: ctrlCode('E'), // cursor up -> ctrl E
          40: ctrlCode('X'), // cursor down -> ctrl X
          45: ctrlCode('O'), // insert -> ctrl O
          46: ctrlCode('G'), // delete -> ctrl G
          8: ctrlCode('H')   // backspace -> ctrl H
        };

        if (keyMappings[ev.keyCode]) {
          sendControlCharacter(keyMappings[ev.keyCode]);
          return;
        }

        if (ev.keyCode === 13) { // Enter
          if (state.term) {
            state.term.prompt("\r");
          } else {
            sendToServer("\r");
          }
          return;
        }

        // Default character input - send to server only, no local echo
        sendToServer(key);
      }

      /**
       * Send control character with error handling
       */
      function sendControlCharacter(charCode) {
        sendToServer(String.fromCharCode(charCode));
      }

      /**
       * Get WebSocket URL with validation
       */
      function getWebSocketUrl() {
        try {
          const urlParams = new URLSearchParams(window.location.search);
          const hostAddress = urlParams.get('altair');
          
          // Validate and sanitize host address
          const altairAddress = hostAddress 
            ? sanitizeHostAddress(hostAddress)
            : window.location.hostname || 'localhost';

          return `ws://${altairAddress}:${CONFIG.WEBSOCKET_PORT}`;
        } catch (error) {
          console.error("Failed to construct WebSocket URL:", error);
          return `ws://localhost:${CONFIG.WEBSOCKET_PORT}`;
        }
      }

      /**
       * Basic host address sanitization
       */
      function sanitizeHostAddress(address) {
        // Remove any protocol prefixes and validate basic format
        const cleaned = address.replace(/^https?:\/\//, '').split('/')[0];
        // Basic validation - allow alphanumeric, dots, hyphens
        if (!/^[a-zA-Z0-9.-]+$/.test(cleaned)) {
          console.warn("Invalid host address, using default");
          return 'localhost';
        }
        return cleaned;
      }

      /**
       * Attempt WebSocket connection with retry logic
       */
      function attemptConnection() {
        if (state.connected) {
          closeConnection();
        }

        const wsUrl = getWebSocketUrl();
        const altairAddress = wsUrl.split('://')[1].split(':')[0];
        
        showMessage(`Connecting to ${altairAddress}...`);

        try {
          state.ws = new WebSocket(wsUrl);
          state.ws.binaryType = "arraybuffer";
          setupWebSocketEventHandlers(altairAddress);
        } catch (error) {
          console.error("Failed to create WebSocket:", error);
          showError("Failed to create connection");
          scheduleReconnect();
        }
      }      /**
       * Set up WebSocket event handlers
       */
      function setupWebSocketEventHandlers(altairAddress) {
        if (!state.ws) return;

        state.ws.onopen = () => {
          console.log("WebSocket connected");
          state.connected = true;
          state.reconnectAttempts = 0;
          showMessage(altairAddress);
          if (state.term) {
            state.term.focus();
          }
        };

        state.ws.onmessage = (event) => {
          if (!state.term) {
            return;
          }

          const data = event.data;

          if (typeof data === "string") {
            writeToTerminal(data);
            return;
          }

          if (data instanceof ArrayBuffer) {
            const decoded = decoder.decode(data, {stream: true});
            writeToTerminal(decoded);
            return;
          }

          if (data instanceof Blob) {
            void data.arrayBuffer()
              .then((buffer) => {
                const decoded = decoder.decode(buffer, {stream: true});
                writeToTerminal(decoded);
              })
              .catch((error) => console.error("Failed to decode blob payload:", error));
          }
        };

        state.ws.onclose = (event) => {
          console.log("WebSocket closed:", event.code, event.reason);
          const trailing = decoder.decode();
          writeToTerminal(trailing);
          state.connected = false;
          state.ws = null;
          showMessage('Connection closed.', true);
          if (!state.userInitiatedDisconnect) {
            scheduleReconnect();
          }
          state.userInitiatedDisconnect = false;
        };

        state.ws.onerror = (error) => {
          console.error("WebSocket error:", error);
          state.connected = false;
          showError("Connection error occurred");
          if (!state.userInitiatedDisconnect) {
            scheduleReconnect();
          }
        };
      }

      /**
       * Close WebSocket connection cleanly
       */
      function closeConnection() {
        if (state.ws) {
          try {
            // Clear event handlers explicitly to prevent memory leaks
            state.ws.onopen = null;
            state.ws.onmessage = null;
            state.ws.onclose = null;
            state.ws.onerror = null;
            
            state.ws.close(1000, "Client disconnect");
          } catch (error) {
            console.error("Error closing WebSocket:", error);
          }
          state.ws = null;
        }
        state.connected = false;
      }

      /**
       * Schedule reconnection attempt
       */
      function scheduleReconnect() {
        if (state.reconnectAttempts < CONFIG.MAX_RECONNECT_ATTEMPTS && state.online) {
          state.reconnectAttempts++;
          const delay = CONFIG.RECONNECT_DELAY * Math.pow(2, state.reconnectAttempts - 1);
          
          showMessage(`Reconnecting in ${delay/1000}s... (${state.reconnectAttempts}/${CONFIG.MAX_RECONNECT_ATTEMPTS})`);
          
          setTimeout(() => {
            if (!state.connected && state.online) {
              attemptConnection();
            }
          }, delay);
        } else {
          showMessage('Max reconnection attempts reached. Refresh to try again.', true);
        }
      }

      /**
       * Apply dark theme
       */
      function setDarkTheme() {
        try {
          localStorage.setItem(CONFIG.STORAGE_THEME_KEY, "dark");
          if (state.term && state.term.options) {
            state.term.options.theme = { 
              background: '#000000', 
              foreground: "#ffffff", 
              cursor: "#ffffff", 
              selectionBackground: "rgba(188,214,141, 0.4)" 
            };
          }
          updateThemeButton("Light");
        } catch (error) {
          console.error("Error applying dark theme:", error);
        }
      }

      /**
       * Apply light theme
       */
      function setLightTheme() {
        try {
          localStorage.setItem(CONFIG.STORAGE_THEME_KEY, "light");
          if (state.term && state.term.options) {
            state.term.options.theme = { 
              background: '#ffffff', 
              foreground: "#000000", 
              cursor: "#000000", 
              selectionBackground: "rgba(188,214,141, 0.4)" 
            };
          }
          updateThemeButton("Dark");
        } catch (error) {
          console.error("Error applying light theme:", error);
        }
      }

      /**
       * Update theme button text
       */
      function updateThemeButton(text) {
        if (elements.toggleTheme) {
          elements.toggleTheme.textContent = text;
        }
      }

      /**
       * Toggle between themes
       */
      function toggleTheme() {
        try {
          const currentTheme = localStorage.getItem(CONFIG.STORAGE_THEME_KEY) || CONFIG.DEFAULT_THEME;
          
          if (currentTheme === "light") {
            setDarkTheme();
          } else {
            setLightTheme();
          }
          
          if (state.term) {
            state.term.focus();
          }
        } catch (error) {
          console.error("Error toggling theme:", error);
        }
      }

      /**
       * Start periodic memory cleanup
       */
      function startPeriodicCleanup() {
        // Clear existing interval first
        if (state.cleanupInterval) {
          clearInterval(state.cleanupInterval);
        }
        
        state.cleanupInterval = setInterval(() => {
          if (state.term && state.connected) {
            try {
              // Log memory usage for monitoring
              logMemoryUsage();
              
              // Clear excess scrollback buffer
              const buffer = state.term.buffer;
              if (buffer && buffer.lines && buffer.lines.length > CONFIG.MAX_SCROLLBACK_LINES) {
                console.log("Cleaning up terminal buffer - lines:", buffer.lines.length);
                // Clear the terminal display but keep connection
                state.term.clear();
              }
            } catch (error) {
              console.error("Error during periodic cleanup:", error);
            }
          }
        }, CONFIG.BUFFER_CLEANUP_INTERVAL);
      }

      /**
       * Log memory usage for monitoring
       */
      function logMemoryUsage() {
        if (performance.memory) {
          const used = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2);
          const total = (performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(2);
          console.log(`Memory - Used: ${used}MB, Total: ${total}MB`);
        }
      }

      /**
       * Cleanup function for page unload
       */
      function cleanup() {
        // Stop periodic cleanup
        if (state.cleanupInterval) {
          clearInterval(state.cleanupInterval);
          state.cleanupInterval = null;
        }
        
        // Clean up terminal event handlers
        cleanupTerminalEventHandlers();
        
        const trailing = decoder.decode();
        writeToTerminal(trailing);

        // Close WebSocket connection
        state.userInitiatedDisconnect = true;
        closeConnection();
        
        // Dispose terminal
        if (state.term) {
          try {
            state.term.dispose();
          } catch (error) {
            console.error("Error disposing terminal:", error);
          }
          state.term = null;
        }
      }

      /**
       * Initialize the application
       */
      function initialize() {
        try {
          console.log("Initializing Altair Terminal...");

          if (!initializeElements()) {
            return false;
          }


          setupReconnectButton();
          setupSendEscButton();
          setupSendCtrlCButton();
          setupMonitorButton();
          initializeNetworkHandlers();

          if (!initializeTerminal()) {
            return false;
          }

          attemptConnection();

          // Start periodic memory cleanup
          startPeriodicCleanup();

          // Set up cleanup on page unload
          window.addEventListener('beforeunload', cleanup);

          updateReconnectButton();

          console.log("Altair Terminal initialized successfully");
          return true;
        } catch (error) {
          console.error("Failed to initialize Altair Terminal:", error);
          showError("Initialization failed: " + error.message);
          return false;
        }
      }

      // Public API
      return {
        initialize,
        toggleTheme,
        cleanup
      };
    })();

    // Global functions for HTML onclick handlers (maintained for compatibility)
    function toggleTheme() {
      AltairTerminal.toggleTheme();
    }

    // Initialize when DOM is loaded
    function initTerminal() {
      AltairTerminal.initialize();
    }
  </script>
  <title>ALTAIR 8800 Emulator</title>
</head>

<body onload="initTerminal();">


  <div style="display: flex; align-items: center; flex-wrap: wrap; gap: 12px 8px; padding-bottom: 8px;">
  <!-- Status text removed as host is now shown in the button -->
    <style>
      .altair-btn {
        margin-left: 8px;
        padding: 2px 14px;
        border-radius: 2px;
        border: 2px solid #e5b800;
        background: #002f00;
        color: #e5b800;
        font-size: 1.1rem;
        line-height: 1.2;
        vertical-align: middle;
        cursor: pointer;
        font-family: GlassTTYVT220, Courier New, Courier, monospace;
        font-weight: 500;
        box-shadow: 0 0 8px #093b09, 0 0 2px #e5b800 inset;
        letter-spacing: 1px;
        text-shadow: none;
      }
      .altair-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .altair-btn:hover:not(:disabled) {
        background: #093b09;
        color: #fffbe6;
        box-shadow: 0 0 12px #e5b800, 0 0 2px #e5b800 inset;
      }
      #version {
        font-family: Courier New, Courier, monospace;
        color: #e5b800;
        font-size: 1rem;
        opacity: 0.7;
        margin-top: 8px;
        text-shadow: none;
      }
    </style>
  <button id="reconnectBtn" class="altair-btn" disabled>Connected</button>
  <button id="sendEscBtn" class="altair-btn">Esc</button>
  <button id="sendCtrlCBtn" class="altair-btn">Ctrl+C</button>
  <button id="monitorBtn" class="altair-btn">CPU Monitor</button>
  <button id="toggleTheme" class="altair-btn" onclick="toggleTheme()">Dark</button>
  </div>




  <div id="terminal"></div>

  <div style="display: flex; align-items: center; gap: 8px; margin-top: 12px;">
    <div id="docs" style="display: flex; gap: 8px; align-items: center;">
      <a href="https://github.com/AzureSphereCloudEnabledAltair8800/RetroGames" target="_blank">Games</a>
      <a href="https://gloveboxes.github.io/Altair-8800-Emulator/" target="_blank">Documentation</a>
      <a href="https://gloveboxes.github.io/Altair-8800-Emulator/60-programming/00-Manuals/" target="_blank">Manuals</a>
    </div>
  </div>

  <div id="version">3.2.1</div>

</body>

</html>
