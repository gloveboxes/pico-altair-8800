<!DOCTYPE html>
<html>

<head>
  <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>

    <style>
    /* Inlined modern.css */
    html,
    input[type=submit],
    div.find a:active {
      background-color: #002f00;
      color: #e5b800;
    }

    a {
      background-color: #002f00;
      color: #e5b800;
    }

    a:hover {
      background-color: #002f00;
      color: #e5b800;
    }

    #docs {
      background-color: #002f00;
      border-width: thick;
      border: white;
      font-family: Courier New;
      font-size: 20px;
      padding: 1px 1px;
    }

    input[type=button] {
      background-color: black;
      border-color: #e5b800;
      border-style: solid;
      border-width: thin;
      color: #e5b800;
      cursor: pointer;
      font-family: Courier New;
      font-size: 20px;
      padding: 1px 4px;
      margin: 2px;
    }

    input[type=text] {
      background-color: black;
      border-color: blue;
      border-style: solid;
      border-width: thin;
      color: #e5b800;
      font-family: Courier New;
      font-size: 20px;
      padding: 1px 1px;
      text-decoration: none;
    }

    body {
      background-color: #002f00;
      color: #e5b800;
      font-family: Courier New;
      font-size: 20px;
      margin-left: 40px;
      margin-right: 40px;
      margin-top: 20px;
      overflow: hidden;
      padding: 1rem;
    }

    #terminal {
      width: calc(100 * 18px * 0.6 + 4px);
      border: 2px solid #e5b800;
      box-sizing: border-box;
      padding: 0;
      margin: 0;
    }

    /* Inlined xterm.css 5.3.0 to ensure the terminal renders when the page
       is embedded into firmware without external assets. */
    .xterm {
      cursor: text;
      position: relative;
      user-select: none;
      -ms-user-select: none;
      -webkit-user-select: none;
    }

    .xterm.focus,
    .xterm:focus {
      outline: none;
    }

    .xterm .xterm-helpers {
      position: absolute;
      top: 0;
      z-index: 5;
    }

    .xterm .xterm-helper-textarea {
      padding: 0;
      border: 0;
      margin: 0;
      position: absolute;
      opacity: 0;
      left: -9999em;
      top: 0;
      width: 0;
      height: 0;
      z-index: -5;
      white-space: nowrap;
      overflow: hidden;
      resize: none;
    }

    .xterm .composition-view {
      background: #000;
      color: #FFF;
      display: none;
      position: absolute;
      white-space: nowrap;
      z-index: 1;
    }

    .xterm .composition-view.active {
      display: block;
    }

    .xterm .xterm-viewport {
      background-color: #000;
      overflow-y: scroll;
      cursor: default;
      position: absolute;
      right: 0;
      left: 0;
      top: 0;
      bottom: 0;
    }

    .xterm .xterm-screen {
      position: relative;
    }

    .xterm .xterm-screen canvas {
      position: absolute;
      left: 0;
      top: 0;
    }

    .xterm .xterm-scroll-area {
      visibility: hidden;
    }

    .xterm-char-measure-element {
      display: inline-block;
      visibility: hidden;
      position: absolute;
      top: 0;
      left: -9999em;
      line-height: normal;
    }

    .xterm.enable-mouse-events {
      cursor: default;
    }

    .xterm.xterm-cursor-pointer,
    .xterm .xterm-cursor-pointer {
      cursor: pointer;
    }

    .xterm.column-select.focus {
      cursor: crosshair;
    }

    .xterm .xterm-accessibility:not(.debug),
    .xterm .xterm-message {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      right: 0;
      z-index: 10;
      color: transparent;
      pointer-events: none;
    }

    .xterm .xterm-accessibility-tree:not(.debug) *::selection {
      color: transparent;
    }

    .xterm .xterm-accessibility-tree {
      user-select: text;
      white-space: pre;
    }

    .xterm .live-region {
      position: absolute;
      left: -9999px;
      width: 1px;
      height: 1px;
      overflow: hidden;
    }

    .xterm-dim {
      opacity: 1 !important;
    }

    .xterm-underline-1 { text-decoration: underline; }
    .xterm-underline-2 { text-decoration: double underline; }
    .xterm-underline-3 { text-decoration: wavy underline; }
    .xterm-underline-4 { text-decoration: dotted underline; }
    .xterm-underline-5 { text-decoration: dashed underline; }

    .xterm-overline {
      text-decoration: overline;
    }

    .xterm-overline.xterm-underline-1 { text-decoration: overline underline; }
    .xterm-overline.xterm-underline-2 { text-decoration: overline double underline; }
    .xterm-overline.xterm-underline-3 { text-decoration: overline wavy underline; }
    .xterm-overline.xterm-underline-4 { text-decoration: overline dotted underline; }
    .xterm-overline.xterm-underline-5 { text-decoration: overline dashed underline; }

    .xterm-strikethrough {
      text-decoration: line-through;
    }

    .xterm-screen .xterm-decoration-container .xterm-decoration {
  	z-index: 6;
  	position: absolute;
    }

    .xterm-screen .xterm-decoration-container .xterm-decoration.xterm-decoration-top-layer {
  	z-index: 7;
    }

    .xterm-decoration-overview-ruler {
      z-index: 8;
      position: absolute;
      top: 0;
      right: 0;
      pointer-events: none;
    }

    .xterm-decoration-top {
      z-index: 2;
      position: relative;
    }
    </style>

  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%23002f00'/><rect x='15' y='20' width='70' height='50' rx='3' fill='%23e5b800' stroke='%23000' stroke-width='2'/><rect x='20' y='25' width='60' height='30' fill='%23000'/><circle cx='30' cy='63' r='3' fill='%23000'/><circle cx='45' cy='63' r='3' fill='%23000'/><circle cx='55' cy='63' r='3' fill='%23000'/><circle cx='70' cy='63' r='3' fill='%23000'/><text x='50' y='43' font-family='monospace' font-size='12' fill='%23e5b800' text-anchor='middle'>8800</text></svg>" type="image/svg+xml">
  <script>
    "use strict";

    /**
     * Altair Terminal Web Client
     * Improved version with better error handling, code organization, and robustness
     */
    const AltairTerminal = (function() {
      // Private state - encapsulated to avoid global pollution
      const state = {
        ws: null,
        connected: false,
        online: navigator.onLine,
        term: null,
        reconnectAttempts: 0,
        maxReconnectAttempts: 5,
        reconnectDelay: 2000,
        pasteHandler: null,
        keyHandler: null,
        cleanupInterval: null,
        reconnectTimer: null,
        userInitiatedDisconnect: false
      };

      const decoder = new TextDecoder("utf-8", {fatal: false});

      // Configuration constants
      const CONFIG = {
        XTERM_FONT: 'Courier',
        XTERM_FONT_SIZE: 18,
        XTERM_ROWS: 30,
        XTERM_COLS: 100,
        MAX_PASTE_LENGTH: 256,
        STORAGE_THEME_KEY: 'altair_theme',
        DEFAULT_THEME: 'dark',
        MAX_SCROLLBACK_LINES: 1000,
        BUFFER_CLEANUP_INTERVAL: 300000, // 5 minutes
        RECONNECT_DELAY: 2000
      };

      // DOM element cache
      const elements = {
        terminal: null,
        hostName: null,
        toggleTheme: null,
        reconnectBtn: null,
        sendEscBtn: null,
        sendCtrlCBtn: null,
        monitorBtn: null
      };

      function sendToServer(data) {
        if (!state.connected || !state.online || !state.ws || state.ws.readyState !== WebSocket.OPEN) {
          return;
        }

        if (typeof data === "string" && data.length === 0) {
          return;
        }

        if (data instanceof ArrayBuffer && data.byteLength === 0) {
          return;
        }

        try {
          state.ws.send(data);
        } catch (error) {
          console.error("Failed to send data:", error);
          showError("Failed to send data to server");
        }
      }

      function writeToTerminal(text) {
        if (!text || !state.term) {
          return;
        }

        try {
          state.term.write(text);
        } catch (error) {
          console.error("Error writing payload to terminal:", error);
        }
      }

      /**
       * Initialize DOM element references with error checking
       */
      function initializeElements() {
        try {
          elements.terminal = document.getElementById("terminal");
          elements.hostName = document.getElementById("host_name");
          elements.toggleTheme = document.getElementById("toggleTheme");
          elements.reconnectBtn = document.getElementById("reconnectBtn");
          elements.sendEscBtn = document.getElementById("sendEscBtn");
          elements.sendCtrlCBtn = document.getElementById("sendCtrlCBtn");
          elements.monitorBtn = document.getElementById("monitorBtn");

          // Validate critical elements exist
          if (!elements.terminal) {
            throw new Error("Terminal container element not found");
          }
        } catch (error) {
          console.error("Failed to initialize DOM elements:", error);
          showError("Failed to initialize terminal interface");
          return false;
        }
        return true;
      }

      // Add sendCtrlC button click handler
      function setupSendCtrlCButton() {
        if (!elements.sendCtrlCBtn) return;
        elements.sendCtrlCBtn.onclick = function() {
          if (state.connected && state.ws && state.ws.readyState === WebSocket.OPEN) {
            sendControlCharacter(3); // Ctrl+C
          }
          if (state.term) {
            state.term.focus();
          }
        };
      }

      // Add sendEsc button click handler
      function setupSendEscButton() {
        if (!elements.sendEscBtn) return;
        elements.sendEscBtn.onclick = function() {
          if (state.connected && state.ws && state.ws.readyState === WebSocket.OPEN) {
            sendControlCharacter(27); // ESC key
          }
          if (state.term) {
            state.term.focus();
          }
        };
      }

      // Add monitor button click handler
      function setupMonitorButton() {
        if (!elements.monitorBtn) return;
        elements.monitorBtn.onclick = function() {
          if (state.connected && state.ws && state.ws.readyState === WebSocket.OPEN) {
            sendControlCharacter(13); // Ctrl+M (CR)
          }
          if (state.term) {
            state.term.focus();
          }
        };
      }

      /**
       * Safe error display without using alert()
       */
      function showError(message) {
        console.error("Altair Terminal Error:", message);
        if (elements.hostName) {
          elements.hostName.textContent = `Error: ${message}`;
          elements.hostName.style.color = 'red';
        }
      }

      /**
       * Safe message display
       */
      function showMessage(message, isError = false) {
        console.log("Altair Terminal:", message);
        if (elements.hostName) {
          elements.hostName.textContent = message;
          elements.hostName.style.color = isError ? 'red' : '';
        }
        updateReconnectButton();
      }

      function updateReconnectButton() {
        if (!elements.reconnectBtn) return;

        const connected = state.connected && state.ws && state.ws.readyState === WebSocket.OPEN;
        elements.reconnectBtn.disabled = false;
        let hostText = "localhost";
        if (connected && state.ws && state.ws.url) {
          try {
            const url = new URL(state.ws.url);
            hostText = url.hostname;
          } catch (e) {}
        } else {
          // Use the host from getWebSocketUrl()
          try {
            const wsUrl = getWebSocketUrl();
            hostText = wsUrl.split('://')[1].split(':')[0];
          } catch (e) {}
        }
        elements.reconnectBtn.textContent = connected ? `Disconnect from ${hostText}` : `Connect to ${hostText}`;

        // Disable/enable control buttons based on connection state
        if (elements.sendEscBtn) elements.sendEscBtn.disabled = !connected;
        if (elements.sendCtrlCBtn) elements.sendCtrlCBtn.disabled = !connected;
        if (elements.monitorBtn) elements.monitorBtn.disabled = !connected;
      }
      // Add reconnect button click handler
      function setupReconnectButton() {
        if (!elements.reconnectBtn) return;
        elements.reconnectBtn.onclick = function() {
          if (state.connected && state.ws && state.ws.readyState === WebSocket.OPEN) {
            // Disconnect
            state.userInitiatedDisconnect = true;
            closeConnection();
            showMessage('Disconnected', true);
            updateReconnectButton();
          } else {
            // Connect - reset reconnect attempts for fresh start
            state.reconnectAttempts = 0;
            state.userInitiatedDisconnect = false;
            attemptConnection();
          }
        };
      }

      /**
       * Network status management
       */
      function initializeNetworkHandlers() {
        window.addEventListener('offline', () => {
          console.log('Connection lost');
          state.online = false;
          showMessage('Connection lost', true);
        });

        window.addEventListener('online', () => {
          console.log('Connection restored');
          state.online = true;
          showMessage('Network connection restored');
          // Attempt to reconnect if not currently connected and not user-disconnected
          if (!state.connected && !state.userInitiatedDisconnect) {
            // Reset reconnect attempts when network comes back
            state.reconnectAttempts = 0;
            cancelReconnect();
            setTimeout(() => attemptConnection(), 1000);
          }
        });
      }

      /**
       * Initialize xterm.js terminal with error handling
       */
      function initializeTerminal() {
        try {
          // Check if Terminal is available
          if (typeof Terminal === 'undefined') {
            throw new Error("xterm.js library not loaded");
          }

          // Get initial theme before creating terminal
          const initialTheme = localStorage.getItem(CONFIG.STORAGE_THEME_KEY) || CONFIG.DEFAULT_THEME;
          const themeColors = initialTheme === "light" 
            ? {
                background: '#ffffff',
                foreground: "#000000",
                cursor: "#000000",
                selectionBackground: "rgba(188,214,141, 0.4)"
              }
            : {
                background: '#000000',
                foreground: "#ffffff",
                cursor: "#ffffff",
                selectionBackground: "rgba(188,214,141, 0.4)"
              };

          state.term = new Terminal({
            cursorBlink: true,
            fontFamily: CONFIG.XTERM_FONT,
            fontSize: CONFIG.XTERM_FONT_SIZE,
            rows: CONFIG.XTERM_ROWS,
            cols: CONFIG.XTERM_COLS,
            theme: themeColors
          });

          if (!elements.terminal) {
            throw new Error("Terminal container not found");
          }

          state.term.open(elements.terminal);
          updateThemeButton(initialTheme === "light" ? "Dark" : "Light");
          // state.term.write('WELCOME TO ALTAIR TERMINAL');

          // Set up terminal prompt function
          state.term.prompt = (msg) => {
            sendToServer(msg);
          };

          state.term.prompt("");
          setupTerminalEventHandlers();
          
          // Set focus to terminal after initialization
          state.term.focus();
          
          return true;
        } catch (error) {
          console.error("Failed to initialize terminal:", error);
          showError("Failed to initialize terminal: " + error.message);
          return false;
        }
      }

      /**
       * Set up terminal event handlers with better error handling
       */
      function setupTerminalEventHandlers() {
        if (!state.term) return;

        // Remove existing handlers first to prevent accumulation
        cleanupTerminalEventHandlers();

        // Store handler references for cleanup
        state.pasteHandler = state.term.onData((data) => {
          // Character mode only - ignore paste data
          return;
        });

        state.keyHandler = state.term.onKey(({key, domEvent}) => {
          try {
            handleKeyPress(key, domEvent);
          } catch (error) {
            console.error("Error handling key press:", error);
          }
        });
      }

      /**
       * Clean up terminal event handlers
       */
      function cleanupTerminalEventHandlers() {
        if (state.pasteHandler) {
          try {
            state.pasteHandler.dispose();
          } catch (error) {
            console.error("Error removing paste handler:", error);
          }
        }
        if (state.keyHandler) {
          try {
            state.keyHandler.dispose();
          } catch (error) {
            console.error("Error removing key handler:", error);
          }
        }
        state.pasteHandler = null;
        state.keyHandler = null;
      }

      /**
       * Handle key press events with better organization
       */
      function handleKeyPress(key, ev) {
        if (ev.ctrlKey) {
          sendControlCharacter(ev.keyCode & 0x1F);
          return;
        }

        if (ev.keyCode === 27) {
          if (state.term) {
            state.term.prompt(key);
            state.term.write(key);
          } else {
            sendToServer(key);
          }
          return;
        }

        handleCharacterMode(key, ev);
      }

      /**
       * Handle character input mode
       */
      function handleCharacterMode(key, ev) {
        const ctrlCode = (letter) => letter.charCodeAt(0) & 0x1F;

        const keyMappings = {
          39: ctrlCode('D'), // cursor right -> ctrl D
          37: ctrlCode('S'), // cursor left -> ctrl S
          38: ctrlCode('E'), // cursor up -> ctrl E
          40: ctrlCode('X'), // cursor down -> ctrl X
          45: ctrlCode('O'), // insert -> ctrl O
          46: ctrlCode('G'), // delete -> ctrl G
          8: ctrlCode('H')   // backspace -> ctrl H
        };

        if (keyMappings[ev.keyCode]) {
          sendControlCharacter(keyMappings[ev.keyCode]);
          return;
        }

        if (ev.keyCode === 13) { // Enter
          if (state.term) {
            state.term.prompt("\r");
          } else {
            sendToServer("\r");
          }
          return;
        }

        // Default character input - send to server only, no local echo
        sendToServer(key);
      }

      /**
       * Send control character with error handling
       */
      function sendControlCharacter(charCode) {
        sendToServer(String.fromCharCode(charCode));
      }

      /**
       * Cancel any pending reconnection attempt
       */
      function cancelReconnect() {
        if (state.reconnectTimer) {
          clearTimeout(state.reconnectTimer);
          state.reconnectTimer = null;
        }
      }

      /**
       * Get WebSocket URL with validation
       */
      function getWebSocketUrl() {
        try {
          const urlParams = new URLSearchParams(window.location.search);
          const hostAddress = urlParams.get('altair');

          // Validate and sanitize host address
          const altairAddress = hostAddress
            ? sanitizeHostAddress(hostAddress)
            : window.location.hostname || 'localhost';

          // Fixed WebSocket port for Altair service
          const port = '8088';

          return `ws://${altairAddress}:${port}`;
        } catch (error) {
          console.error("Failed to construct WebSocket URL:", error);
          return 'ws://localhost:8088';
        }
      }

      /**
       * Basic host address sanitization
       */
      function sanitizeHostAddress(address) {
        // Remove any protocol prefixes and validate basic format
        const cleaned = address.replace(/^https?:\/\//, '').split('/')[0];
        // Basic validation - allow alphanumeric, dots, hyphens
        if (!/^[a-zA-Z0-9.-]+$/.test(cleaned)) {
          console.warn("Invalid host address, using default");
          return 'localhost';
        }
        return cleaned;
      }

      /**
       * Attempt WebSocket connection with retry logic
       */
      function attemptConnection() {
        // Cancel any pending reconnection attempts
        cancelReconnect();
        
        // Close existing connection if any
        if (state.ws) {
          closeConnection();
        }

        // Clear the user disconnect flag when manually connecting
        state.userInitiatedDisconnect = false;

          const wsUrl = getWebSocketUrl();
        const altairAddress = wsUrl.split('://')[1].split(':')[0];
        
        showMessage(`Connecting to ${altairAddress}...`);

        try {
          state.ws = new WebSocket(wsUrl);
          state.ws.binaryType = "arraybuffer";
          setupWebSocketEventHandlers(altairAddress);
        } catch (error) {
          console.error("Failed to create WebSocket:", error);
          showError("Failed to create connection");
          state.connected = false;
          scheduleReconnect();
        }
      }      /**
       * Set up WebSocket event handlers
       */
      function setupWebSocketEventHandlers(altairAddress) {
        if (!state.ws) return;

        state.ws.onopen = () => {
          console.log("WebSocket connected");
          state.connected = true;
          // Only reset reconnect attempts after successful connection
          // This prevents rapid reconnection loops
          setTimeout(() => {
            if (state.connected && state.ws && state.ws.readyState === WebSocket.OPEN) {
              state.reconnectAttempts = 0;
            }
          }, 5000);
          showMessage(altairAddress);
          if (state.term) {
            state.term.focus();
          }
        };

        state.ws.onmessage = (event) => {
          if (!state.term) {
            return;
          }

          const data = event.data;

          if (typeof data === "string") {
            writeToTerminal(data);
            return;
          }

          if (data instanceof ArrayBuffer) {
            const decoded = decoder.decode(data, {stream: true});
            writeToTerminal(decoded);
            return;
          }

          if (data instanceof Blob) {
            void data.arrayBuffer()
              .then((buffer) => {
                const decoded = decoder.decode(buffer, {stream: true});
                writeToTerminal(decoded);
              })
              .catch((error) => console.error("Failed to decode blob payload:", error));
          }
        };

        state.ws.onclose = (event) => {
          console.log("WebSocket closed:", event.code, event.reason);
          const trailing = decoder.decode();
          writeToTerminal(trailing);
          
          // Synchronize state
          state.connected = false;
          state.ws = null;
          
          // Only show message and attempt reconnect if not user initiated
          if (!state.userInitiatedDisconnect) {
            showMessage('Connection closed. Reconnecting...', true);
            scheduleReconnect();
          } else {
            showMessage('Disconnected.', true);
            // Reset flag after handling disconnect
            state.userInitiatedDisconnect = false;
          }
        };

        state.ws.onerror = (error) => {
          console.error("WebSocket error:", error);
          state.connected = false;
          // Don't call scheduleReconnect here - onclose will handle it
          // This prevents double reconnection attempts
        };
      }

      /**
       * Close WebSocket connection cleanly
       */
      function closeConnection() {
        // Cancel any pending reconnection attempts
        cancelReconnect();
        
        if (state.ws) {
          try {
            // Clear event handlers explicitly to prevent memory leaks
            state.ws.onopen = null;
            state.ws.onmessage = null;
            state.ws.onclose = null;
            state.ws.onerror = null;
            
            // Only close if not already closed/closing
            if (state.ws.readyState === WebSocket.OPEN || state.ws.readyState === WebSocket.CONNECTING) {
              state.ws.close(1000, "Client disconnect");
            }
          } catch (error) {
            console.error("Error closing WebSocket:", error);
          }
          state.ws = null;
        }
        state.connected = false;
      }

      /**
       * Schedule reconnection attempt
       */
      function scheduleReconnect() {
        // Don't schedule if already scheduled or if max attempts reached
        if (state.reconnectTimer) {
          return;
        }
        
        if (state.reconnectAttempts >= CONFIG.MAX_RECONNECT_ATTEMPTS) {
          showMessage('Max reconnection attempts reached. Click Connect to retry.', true);
          return;
        }
        
        if (!state.online) {
          showMessage('No network connection.', true);
          return;
        }
        
        state.reconnectAttempts++;
        const delay = CONFIG.RECONNECT_DELAY * Math.pow(2, state.reconnectAttempts - 1);
        
        showMessage(`Reconnecting in ${delay/1000}s... (${state.reconnectAttempts}/${CONFIG.MAX_RECONNECT_ATTEMPTS})`);
        
        state.reconnectTimer = setTimeout(() => {
          state.reconnectTimer = null;
          if (!state.connected && state.online && !state.userInitiatedDisconnect) {
            attemptConnection();
          }
        }, delay);
      }

      /**
       * Apply dark theme
       */
      function setDarkTheme() {
        try {
          localStorage.setItem(CONFIG.STORAGE_THEME_KEY, "dark");
          if (state.term && state.term.options) {
            state.term.options.theme = { 
              background: '#000000', 
              foreground: "#ffffff", 
              cursor: "#ffffff", 
              selectionBackground: "rgba(188,214,141, 0.4)" 
            };
          }
          updateThemeButton("Light");
        } catch (error) {
          console.error("Error applying dark theme:", error);
        }
      }

      /**
       * Apply light theme
       */
      function setLightTheme() {
        try {
          localStorage.setItem(CONFIG.STORAGE_THEME_KEY, "light");
          if (state.term && state.term.options) {
            state.term.options.theme = { 
              background: '#ffffff', 
              foreground: "#000000", 
              cursor: "#000000", 
              selectionBackground: "rgba(188,214,141, 0.4)" 
            };
          }
          updateThemeButton("Dark");
        } catch (error) {
          console.error("Error applying light theme:", error);
        }
      }

      /**
       * Update theme button text
       */
      function updateThemeButton(text) {
        if (elements.toggleTheme) {
          elements.toggleTheme.textContent = text;
        }
      }

      /**
       * Toggle between themes
       */
      function toggleTheme() {
        try {
          const currentTheme = localStorage.getItem(CONFIG.STORAGE_THEME_KEY) || CONFIG.DEFAULT_THEME;
          
          if (currentTheme === "light") {
            setDarkTheme();
          } else {
            setLightTheme();
          }
          
          if (state.term) {
            state.term.focus();
          }
        } catch (error) {
          console.error("Error toggling theme:", error);
        }
      }

      /**
       * Start periodic memory cleanup
       */
      function startPeriodicCleanup() {
        // Clear existing interval first
        if (state.cleanupInterval) {
          clearInterval(state.cleanupInterval);
        }
        
        state.cleanupInterval = setInterval(() => {
          if (state.term && state.connected) {
            try {
              // Log memory usage for monitoring
              logMemoryUsage();
              
              // Clear excess scrollback buffer
              const buffer = state.term.buffer;
              if (buffer && buffer.lines && buffer.lines.length > CONFIG.MAX_SCROLLBACK_LINES) {
                console.log("Cleaning up terminal buffer - lines:", buffer.lines.length);
                // Clear the terminal display but keep connection
                state.term.clear();
              }
            } catch (error) {
              console.error("Error during periodic cleanup:", error);
            }
          }
        }, CONFIG.BUFFER_CLEANUP_INTERVAL);
      }

      /**
       * Log memory usage for monitoring
       */
      function logMemoryUsage() {
        if (performance.memory) {
          const used = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2);
          const total = (performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(2);
          console.log(`Memory - Used: ${used}MB, Total: ${total}MB`);
        }
      }

      /**
       * Cleanup function for page unload
       */
      function cleanup() {
        // Stop periodic cleanup
        if (state.cleanupInterval) {
          clearInterval(state.cleanupInterval);
          state.cleanupInterval = null;
        }
        
        // Cancel any pending reconnection
        cancelReconnect();
        
        // Clean up terminal event handlers
        cleanupTerminalEventHandlers();
        
        const trailing = decoder.decode();
        writeToTerminal(trailing);

        // Close WebSocket connection
        state.userInitiatedDisconnect = true;
        closeConnection();
        
        // Dispose terminal
        if (state.term) {
          try {
            state.term.dispose();
          } catch (error) {
            console.error("Error disposing terminal:", error);
          }
          state.term = null;
        }
      }

      /**
       * Initialize the application
       */
      function initialize() {
        try {
          console.log("Initializing Altair Terminal...");

          if (!initializeElements()) {
            return false;
          }


          setupReconnectButton();
          setupSendEscButton();
          setupSendCtrlCButton();
          setupMonitorButton();
          initializeNetworkHandlers();

          if (!initializeTerminal()) {
            return false;
          }

          attemptConnection();

          // Start periodic memory cleanup
          startPeriodicCleanup();

          // Set up cleanup on page unload
          window.addEventListener('beforeunload', cleanup);

          updateReconnectButton();

          console.log("Altair Terminal initialized successfully");
          return true;
        } catch (error) {
          console.error("Failed to initialize Altair Terminal:", error);
          showError("Initialization failed: " + error.message);
          return false;
        }
      }

      // Public API
      return {
        initialize,
        toggleTheme,
        cleanup
      };
    })();

    // Global functions for HTML onclick handlers (maintained for compatibility)
    function toggleTheme() {
      AltairTerminal.toggleTheme();
    }

    // Initialize when DOM is loaded
    function initTerminal() {
      AltairTerminal.initialize();
    }
  </script>
  <title>ALTAIR 8800 Emulator</title>
</head>

<body onload="initTerminal();">


  <div style="display: flex; align-items: center; flex-wrap: wrap; gap: 12px 8px; padding-bottom: 8px;">
  <!-- Status text removed as host is now shown in the button -->
    <style>
      .altair-btn {
        margin-left: 8px;
        padding: 2px 14px;
        border-radius: 2px;
        border: 2px solid #e5b800;
        background: #002f00;
        color: #e5b800;
        font-size: 1.1rem;
        line-height: 1.2;
        vertical-align: middle;
        cursor: pointer;
        font-family: GlassTTYVT220, Courier New, Courier, monospace;
        font-weight: 500;
        box-shadow: 0 0 8px #093b09, 0 0 2px #e5b800 inset;
        letter-spacing: 1px;
        text-shadow: none;
      }
      .altair-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .altair-btn:hover:not(:disabled) {
        background: #093b09;
        color: #fffbe6;
        box-shadow: 0 0 12px #e5b800, 0 0 2px #e5b800 inset;
      }
      #version {
        font-family: Courier New, Courier, monospace;
        color: #e5b800;
        font-size: 1rem;
        opacity: 0.7;
        margin-top: 8px;
        text-shadow: none;
      }
    </style>
  <button id="reconnectBtn" class="altair-btn" disabled>Connected</button>
  <button id="sendEscBtn" class="altair-btn">Esc</button>
  <button id="sendCtrlCBtn" class="altair-btn">Ctrl+C</button>
  <button id="monitorBtn" class="altair-btn">CPU Monitor</button>
  <button id="toggleTheme" class="altair-btn" onclick="toggleTheme()">Dark</button>
  </div>




  <div id="terminal"></div>

  <div style="display: flex; align-items: center; gap: 8px; margin-top: 12px;">
    <div id="docs" style="display: flex; gap: 8px; align-items: center;">
      <a href="https://github.com/AzureSphereCloudEnabledAltair8800/RetroGames" target="_blank">Games</a>
      <a href="https://gloveboxes.github.io/Altair-8800-Emulator/" target="_blank">Documentation</a>
      <a href="https://gloveboxes.github.io/Altair-8800-Emulator/60-programming/00-Manuals/" target="_blank">Manuals</a>
    </div>
  </div>

  <div id="version">3.2.2</div>

</body>

</html>
